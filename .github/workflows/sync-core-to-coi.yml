name: Sync CORE to COI

on:
  push:
    paths:
      - 'Fibi-*-Release/**/CORE/**'
      - 'Fibi-*-Release/**/ROUTINES/**'
      - 'Sprint-*/**/CORE/**'
      - 'Sprint-*/**/ROUTINES/**'

permissions:
  contents: write
  pull-requests: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout fibi-test
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Get commit author info
        id: author
        run: |
          AUTHOR_EMAIL=$(git log -1 --pretty=format:"%ae" || echo "${{ github.actor }}@users.noreply.github.com")
          AUTHOR_NAME=$(git log -1 --pretty=format:"%an" || echo "${{ github.actor }}")
          echo "author_email=$AUTHOR_EMAIL" >> $GITHUB_OUTPUT
          echo "author_name=$AUTHOR_NAME" >> $GITHUB_OUTPUT
          echo "Commit author: $AUTHOR_NAME <$AUTHOR_EMAIL>"
      
      - name: Get current branch name
        id: branch
        run: |
          # Extract branch name from ref (e.g., refs/heads/feature-branch -> feature-branch)
          BRANCH_NAME="${{ github.ref_name }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "Current branch: $BRANCH_NAME"
      
      - name: Check if CORE files changed
        id: check-core
        run: |
          # Get all changed files (modified, added, deleted)
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          # Get deleted files specifically
          DELETED_FILES=$(git diff --name-only --diff-filter=D HEAD~1 HEAD || true)
          # Get added files specifically
          ADDED_FILES=$(git diff --name-only --diff-filter=A HEAD~1 HEAD || true)
          # Get modified files
          MODIFIED_FILES=$(git diff --name-only --diff-filter=M HEAD~1 HEAD || true)
          
          # Combine all changes (additions, modifications, deletions)
          ALL_CORE_CHANGES=$(echo -e "$CHANGED_FILES" | grep -E '(Fibi-.*-Release|Sprint-.*)/.*/CORE' || true)
          
          # Check for Release and Sprint CORE changes and extract folder names
          RELEASE_CHANGES=$(echo "$ALL_CORE_CHANGES" | grep -oP "Fibi-[^/]+-Release" | sort -u || true)
          SPRINT_CHANGES=$(echo "$ALL_CORE_CHANGES" | grep -oP "Sprint-[^/]+" | sort -u || true)
          
          if [ -n "$RELEASE_CHANGES" ] || [ -n "$SPRINT_CHANGES" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            if [ -n "$RELEASE_CHANGES" ]; then
              echo "release_changed=true" >> $GITHUB_OUTPUT
              echo "releases=$RELEASE_CHANGES" >> $GITHUB_OUTPUT
              echo "Release CORE files changed in: $RELEASE_CHANGES"
            fi
            if [ -n "$SPRINT_CHANGES" ]; then
              echo "sprint_changed=true" >> $GITHUB_OUTPUT
              echo "sprints=$SPRINT_CHANGES" >> $GITHUB_OUTPUT
              echo "Sprint CORE files changed in: $SPRINT_CHANGES"
            fi
          fi
          
          # Check for deleted release and sprint CORE folders
          DELETED_RELEASES=$(echo "$DELETED_FILES" | grep -oP "Fibi-[^/]+-Release" | sort -u || true)
          DELETED_SPRINTS=$(echo "$DELETED_FILES" | grep -oP "Sprint-[^/]+" | sort -u || true)
          
          if [ -n "$DELETED_RELEASES" ] || [ -n "$DELETED_SPRINTS" ]; then
            if [ -n "$DELETED_RELEASES" ]; then
              echo "release_deleted=true" >> $GITHUB_OUTPUT
              echo "deleted_releases=$DELETED_RELEASES" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è  Release CORE folders deleted: $DELETED_RELEASES"
            fi
            if [ -n "$DELETED_SPRINTS" ]; then
              echo "sprint_deleted=true" >> $GITHUB_OUTPUT
              echo "deleted_sprints=$DELETED_SPRINTS" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è  Sprint CORE folders deleted: $DELETED_SPRINTS"
            fi
          fi
          
          # Check for routines YAML file changes - ONLY from BASE/CORE
          # (PROCEDURES.yaml, VIEWS.yaml, FUNCTIONS.yaml, etc.)
          ROUTINES_YAML_CHANGES=$(echo "$ALL_CORE_CHANGES" | grep -E 'BASE/CORE/.*\.(yaml|yml)$' | grep -E '(PROCEDURES|VIEWS|FUNCTIONS|TRIGGERS)\.(yaml|yml)$' || true)
          if [ -n "$ROUTINES_YAML_CHANGES" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "routines_yaml_changed=true" >> $GITHUB_OUTPUT
            echo "Routines YAML files changed: $ROUTINES_YAML_CHANGES"
          fi
          
          # Set default if no changes
          if [ -z "$ALL_CORE_CHANGES" ] && [ -z "$DELETED_RELEASES" ] && [ -z "$ROUTINES_YAML_CHANGES" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No CORE files changed"
          fi
      
      - name: Verify Secret
        if: steps.check-core.outputs.changed == 'true'
        run: |
          if [ -z "$GH_COI_PUSH_TOKEN" ]; then
            echo "‚ùå ERROR: GH_COI_PUSH_TOKEN secret is empty or not set!"
            echo "Please check: https://github.com/eprabhu/fibi-test/settings/secrets/actions"
            exit 1
          else
            TOKEN_LENGTH=${#GH_COI_PUSH_TOKEN}
            echo "‚úÖ Token secret exists (length: $TOKEN_LENGTH characters)"
            if [ $TOKEN_LENGTH -lt 10 ]; then
              echo "‚ö†Ô∏è  WARNING: Token seems too short. Please verify it's correct."
            fi
          fi
        env:
          GH_COI_PUSH_TOKEN: ${{ secrets.GH_COI_PUSH_TOKEN }}
      
      - name: Checkout COI
        if: steps.check-core.outputs.changed == 'true'
        run: |
          echo "Cloning COI repository..."
          git clone https://x-access-token:$GH_COI_PUSH_TOKEN@github.com/eprabhu/coi.git coi-repo
          cd coi-repo
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Get the branch name from the source repository
          SOURCE_BRANCH="${{ steps.branch.outputs.branch_name }}"
          echo "Checking out branch: $SOURCE_BRANCH"
          
          # Check if branch exists in COI repository
          if git ls-remote --heads origin "$SOURCE_BRANCH" | grep -q "$SOURCE_BRANCH"; then
            echo "Branch $SOURCE_BRANCH exists in COI, checking it out..."
            git checkout "$SOURCE_BRANCH"
          else
            echo "Branch $SOURCE_BRANCH does not exist in COI, creating it..."
            git checkout -b "$SOURCE_BRANCH"
          fi
        env:
          GH_COI_PUSH_TOKEN: ${{ secrets.GH_COI_PUSH_TOKEN }}
      
      - name: Sync CORE files
        if: steps.check-core.outputs.changed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_COI_PUSH_TOKEN }}
        run: |
          echo "Syncing CORE files..."
          
          # Create base destination directory
          mkdir -p coi-repo/DB/CORE
          
          # Handle deleted Release CORE folders
          if [ "${{ steps.check-core.outputs.release_deleted }}" == "true" ]; then
            echo "‚ö†Ô∏è  Handling deleted Release CORE folders..."
            DELETED_RELEASES="${{ steps.check-core.outputs.deleted_releases }}"
            
            for RELEASE in $DELETED_RELEASES; do
              DEST_DIR="coi-repo/DB/CORE/$RELEASE"
              if [ -d "$DEST_DIR" ]; then
                echo "Removing deleted release folder: $DEST_DIR"
                rm -rf "$DEST_DIR"
                echo "‚úÖ Removed $RELEASE from COI"
              fi
            done
          fi
          
          # Sync Release CORE folders (if changed but not deleted)
          if [ "${{ steps.check-core.outputs.release_changed }}" == "true" ]; then
            echo "Syncing Release CORE folders..."
            
            # Get changed files to find which releases need syncing
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
            
            # Find all unique release folders with CORE changes
            RELEASES=$(echo "$CHANGED_FILES" | grep -oP "Fibi-[^/]+-Release" | sort -u)
            
            for RELEASE in $RELEASES; do
              echo "Processing release: $RELEASE"
              
              # Check if this release folder still exists in source
              if [ ! -d "$RELEASE" ]; then
                echo "‚ö†Ô∏è  Release folder $RELEASE no longer exists, skipping sync"
                continue
              fi
              
              # Find CORE folder in this release - ONLY BASE/CORE (not client-based CORE)
              CORE_PATH="$RELEASE/BASE/CORE"
              
              if [ -n "$CORE_PATH" ] && [ -d "$CORE_PATH" ]; then
                echo "Found CORE folder at: $CORE_PATH"
                
                # Create destination directory for this release
                DEST_DIR="coi-repo/DB/CORE/$RELEASE"
                
                # Remove existing release folder if it exists (for clean sync)
                if [ -d "$DEST_DIR" ]; then
                  echo "Removing existing $RELEASE folder for clean sync..."
                  rm -rf "$DEST_DIR"
                fi
                
                # Create fresh directory
                mkdir -p "$DEST_DIR"
                
                # Copy CORE folder contents (not the CORE folder itself)
                echo "Copying from $CORE_PATH to $DEST_DIR"
                cp -r "$CORE_PATH"/* "$DEST_DIR/" || true
                
                echo "‚úÖ Synced $RELEASE CORE to $DEST_DIR"
              else
                echo "‚ö†Ô∏è  No CORE folder found in $RELEASE"
                # If CORE folder doesn't exist in source, remove from destination
                DEST_DIR="coi-repo/DB/CORE/$RELEASE"
                if [ -d "$DEST_DIR" ]; then
                  echo "Removing $RELEASE folder from COI (CORE folder deleted in source)"
                  rm -rf "$DEST_DIR"
                fi
              fi
            done
          fi
          
          # Handle deleted Sprint CORE folders
          if [ "${{ steps.check-core.outputs.sprint_deleted }}" == "true" ]; then
            echo "‚ö†Ô∏è  Handling deleted Sprint CORE folders..."
            DELETED_SPRINTS="${{ steps.check-core.outputs.deleted_sprints }}"
            
            for SPRINT in $DELETED_SPRINTS; do
              DEST_DIR="coi-repo/DB/CORE/$SPRINT"
              if [ -d "$DEST_DIR" ]; then
                echo "Removing deleted sprint folder: $DEST_DIR"
                rm -rf "$DEST_DIR"
                echo "‚úÖ Removed $SPRINT from COI"
              fi
            done
          fi
          
          # Sync Sprint CORE folders (if changed but not deleted)
          if [ "${{ steps.check-core.outputs.sprint_changed }}" == "true" ]; then
            echo "Syncing Sprint CORE folders..."
            
            # Get changed files to find which sprints need syncing
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
            
            # Find all unique sprint folders with CORE changes
            SPRINTS=$(echo "$CHANGED_FILES" | grep -oP "Sprint-[^/]+" | sort -u)
            
            for SPRINT in $SPRINTS; do
              echo "Processing sprint: $SPRINT"
              
              # Check if this sprint folder still exists in source
              if [ ! -d "$SPRINT" ]; then
                echo "‚ö†Ô∏è  Sprint folder $SPRINT no longer exists, skipping sync"
                continue
              fi
              
              # Find CORE folder in this sprint - ONLY BASE/CORE (not client-based CORE)
              CORE_PATH="$SPRINT/BASE/CORE"
              
              if [ -n "$CORE_PATH" ] && [ -d "$CORE_PATH" ]; then
                echo "Found CORE folder at: $CORE_PATH"
                
                # Create destination directory for this sprint
                DEST_DIR="coi-repo/DB/CORE/$SPRINT"
                
                # Remove existing sprint folder if it exists (for clean sync)
                if [ -d "$DEST_DIR" ]; then
                  echo "Removing existing $SPRINT folder for clean sync..."
                  rm -rf "$DEST_DIR"
                fi
                
                # Create fresh directory
                mkdir -p "$DEST_DIR"
                
                # Copy CORE folder contents (not the CORE folder itself)
                echo "Copying from $CORE_PATH to $DEST_DIR"
                cp -r "$CORE_PATH"/* "$DEST_DIR/" || true
                
                echo "‚úÖ Synced $SPRINT CORE to $DEST_DIR"
              else
                echo "‚ö†Ô∏è  No CORE folder found in $SPRINT"
                # If CORE folder doesn't exist in source, remove from destination
                DEST_DIR="coi-repo/DB/CORE/$SPRINT"
                if [ -d "$DEST_DIR" ]; then
                  echo "Removing $SPRINT folder from COI (CORE folder deleted in source)"
                  rm -rf "$DEST_DIR"
                fi
              fi
            done
          fi
          
          # Sync ROUTINES files if routines YAML files changed
          if [ "${{ steps.check-core.outputs.routines_yaml_changed }}" == "true" ]; then
            echo "Syncing ROUTINES files from changed YAML files..."
            
            # Get changed routines YAML files - ONLY from BASE/CORE
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
            # Filter to only BASE/CORE (exclude client-based CORE)
            ROUTINES_YAML_FILES=$(echo "$CHANGED_FILES" | grep -E 'BASE/CORE/.*\.(yaml|yml)$' | grep -E '(PROCEDURES|VIEWS|FUNCTIONS|TRIGGERS)\.(yaml|yml)$' || true)
            
            # Process each changed YAML file
            for YAML_FILE in $ROUTINES_YAML_FILES; do
              if [ ! -f "$YAML_FILE" ]; then
                echo "‚ö†Ô∏è  YAML file $YAML_FILE not found (may have been deleted), skipping"
                continue
              fi
              
              echo "Processing YAML file: $YAML_FILE"
              
              # Extract all sqlFile paths from YAML
              # Pattern: sqlFile: followed by path: on next line
              SQL_PATHS=$(awk '/sqlFile:/{getline; if(/path:/){gsub(/.*path:[[:space:]]*/, ""); gsub(/[[:space:]]*$/, ""); if($0 != "") print}}' "$YAML_FILE" || true)
              
              if [ -z "$SQL_PATHS" ]; then
                echo "No sqlFile paths found in $YAML_FILE"
                continue
              fi
              
              # Copy each SQL file
              for SQL_PATH in $SQL_PATHS; do
                echo "Found SQL path: $SQL_PATH"
                
                # Normalize path (remove leading/trailing spaces)
                SQL_PATH=$(echo "$SQL_PATH" | xargs)
                
                # Handle different path formats - find source file
                SOURCE_FILE=""
                SQL_FILENAME=$(basename "$SQL_PATH")
                
                # Strategy 1: Try path as-is
                if [ -f "$SQL_PATH" ]; then
                  SOURCE_FILE="$SQL_PATH"
                  echo "Found file at (as-is): $SQL_PATH"
                fi
                
                # Strategy 2: If path starts with ROUTINES/FIBI_CORE, try ROUTINES/BASE/FIBI_CORE
                if [ -z "$SOURCE_FILE" ] && echo "$SQL_PATH" | grep -q "^ROUTINES/FIBI_CORE"; then
                  BASE_PATH=$(echo "$SQL_PATH" | sed 's|^ROUTINES/FIBI_CORE|ROUTINES/BASE/FIBI_CORE|')
                  if [ -f "$BASE_PATH" ]; then
                    SOURCE_FILE="$BASE_PATH"
                    echo "Found file at (BASE FIBI_CORE path): $BASE_PATH"
                  fi
                fi
                
                # Strategy 3: If path starts with ROUTINES/CORE, try ROUTINES/BASE/CORE (common pattern)
                if [ -z "$SOURCE_FILE" ] && echo "$SQL_PATH" | grep -q "^ROUTINES/CORE"; then
                  BASE_PATH=$(echo "$SQL_PATH" | sed 's|^ROUTINES/CORE|ROUTINES/BASE/CORE|')
                  if [ -f "$BASE_PATH" ]; then
                    SOURCE_FILE="$BASE_PATH"
                    echo "Found file at (BASE path): $BASE_PATH"
                  fi
                fi
                
                # Strategy 4: Try ROUTINES/BASE/ + relative path from ROUTINES/
                if [ -z "$SOURCE_FILE" ] && echo "$SQL_PATH" | grep -q "^ROUTINES/"; then
                  RELATIVE_PATH=$(echo "$SQL_PATH" | sed 's|^ROUTINES/||')
                  TRY_PATH="ROUTINES/BASE/$RELATIVE_PATH"
                  if [ -f "$TRY_PATH" ]; then
                    SOURCE_FILE="$TRY_PATH"
                    echo "Found file at (BASE relative): $TRY_PATH"
                  fi
                fi
                
                # Strategy 5: Find file by name in ROUTINES directories
                if [ -z "$SOURCE_FILE" ]; then
                  echo "Searching for file by name: $SQL_FILENAME"
                  SOURCE_FILE=$(find . -type f -name "$SQL_FILENAME" ! -path "*/.git/*" ! -path "*/coi-repo/*" | grep -E "ROUTINES.*(CORE|FIBI_CORE)" | head -1)
                  if [ -n "$SOURCE_FILE" ]; then
                    echo "Found by filename at: $SOURCE_FILE"
                  fi
                fi
                
                # Strategy 6: Try with full path pattern (last resort)
                if [ -z "$SOURCE_FILE" ]; then
                  SOURCE_FILE=$(find . -type f -path "*/$SQL_PATH" ! -path "*/.git/*" ! -path "*/coi-repo/*" | head -1)
                  if [ -n "$SOURCE_FILE" ]; then
                    echo "Found by path pattern at: $SOURCE_FILE"
                  fi
                fi
                
                if [ -n "$SOURCE_FILE" ] && [ -f "$SOURCE_FILE" ]; then
                  # Determine destination path: DB/ROUTINES/CORE/(PROCEDURES|FUNCTIONS|VIEWS)/*.sql
                  SQL_FILENAME=$(basename "$SOURCE_FILE")
                  
                  # Extract type (PROCEDURES, FUNCTIONS, VIEWS, TRIGGERS) from source path
                  ROUTINE_TYPE=""
                  if echo "$SOURCE_FILE" | grep -qiE "(PROCEDURES|PROC)"; then
                    ROUTINE_TYPE="PROCEDURES"
                  elif echo "$SOURCE_FILE" | grep -qiE "(FUNCTIONS|FUNC)"; then
                    ROUTINE_TYPE="FUNCTIONS"
                  elif echo "$SOURCE_FILE" | grep -qiE "VIEWS"; then
                    ROUTINE_TYPE="VIEWS"
                  elif echo "$SOURCE_FILE" | grep -qiE "TRIGGERS"; then
                    ROUTINE_TYPE="TRIGGERS"
                  else
                    # Try to extract from path structure
                    if echo "$SOURCE_FILE" | grep -qE "/PROCEDURES/"; then
                      ROUTINE_TYPE="PROCEDURES"
                    elif echo "$SOURCE_FILE" | grep -qE "/FUNCTIONS/"; then
                      ROUTINE_TYPE="FUNCTIONS"
                    elif echo "$SOURCE_FILE" | grep -qE "/VIEWS/"; then
                      ROUTINE_TYPE="VIEWS"
                    elif echo "$SOURCE_FILE" | grep -qE "/TRIGGERS/"; then
                      ROUTINE_TYPE="TRIGGERS"
                    else
                      # Default to FUNCTIONS if cannot determine
                      ROUTINE_TYPE="FUNCTIONS"
                      echo "‚ö†Ô∏è  Could not determine routine type, defaulting to FUNCTIONS"
                    fi
                  fi
                  
                  # Build destination: DB/ROUTINES/CORE/{TYPE}/{filename}.sql
                  DEST_PATH="DB/ROUTINES/CORE/$ROUTINE_TYPE/$SQL_FILENAME"
                  DEST_FILE="coi-repo/$DEST_PATH"
                  DEST_DIR=$(dirname "$DEST_FILE")
                  
                  # Create destination directory (create parent directories if needed)
                  echo "Creating destination directory: $DEST_DIR"
                  mkdir -p "$DEST_DIR"
                  
                  # Copy the file (will replace if exists)
                  echo "Copying $SOURCE_FILE to $DEST_FILE"
                  cp -f "$SOURCE_FILE" "$DEST_FILE" || {
                    echo "‚ö†Ô∏è  Failed to copy $SOURCE_FILE to $DEST_FILE"
                    continue
                  }
                  echo "‚úÖ Synced routine file: $DEST_PATH"
                else
                  echo "‚ö†Ô∏è  SQL file not found: $SQL_PATH"
                  echo "   Searched paths:"
                  echo "   - $SQL_PATH"
                  if echo "$SQL_PATH" | grep -q "^ROUTINES/CORE"; then
                    BASE_PATH=$(echo "$SQL_PATH" | sed 's|^ROUTINES/CORE|ROUTINES/BASE/CORE|')
                    echo "   - $BASE_PATH"
                  fi
                  SQL_FILENAME=$(basename "$SQL_PATH")
                  echo "   - Files named: $SQL_FILENAME"
                fi
              done
            done
            
            echo "‚úÖ Finished syncing ROUTINES files"
            
            # Update all YAML files in COI repo to reflect new routine paths
            echo "Updating YAML files in COI repo with new routine paths..."
            cd coi-repo
            
            # Find all YAML files in DB/CORE that might reference routines
            YAML_FILES=$(find DB/CORE -type f \( -name "PROCEDURES.yaml" -o -name "PROCEDURES.yml" -o -name "FUNCTIONS.yaml" -o -name "FUNCTIONS.yml" -o -name "VIEWS.yaml" -o -name "VIEWS.yml" -o -name "TRIGGERS.yaml" -o -name "TRIGGERS.yml" \) 2>/dev/null || true)
            
            if [ -n "$YAML_FILES" ]; then
              for COI_YAML in $YAML_FILES; do
                if [ ! -f "$COI_YAML" ]; then
                  continue
                fi
                
                echo "Processing YAML: $COI_YAML"
                
                # Extract all old SQL paths from YAML
                OLD_PATHS=$(awk '/sqlFile:/{getline; if(/path:/){gsub(/.*path:[[:space:]]*/, ""); gsub(/[[:space:]]*$/, ""); if($0 != "") print}}' "$COI_YAML" 2>/dev/null || true)
                
                if [ -z "$OLD_PATHS" ]; then
                  continue
                fi
                
                # Update each path
                for OLD_PATH in $OLD_PATHS; do
                  OLD_PATH=$(echo "$OLD_PATH" | xargs)
                  
                  # Skip if already using new path format
                  if echo "$OLD_PATH" | grep -q "^DB/ROUTINES/CORE"; then
                    continue
                  fi
                  
                  # Extract filename and determine type
                  SQL_FILENAME=$(basename "$OLD_PATH")
                  
                  # Determine routine type from old path or filename
                  ROUTINE_TYPE="FUNCTIONS"
                  if echo "$OLD_PATH" | grep -qiE "(PROCEDURES|PROC)"; then
                    ROUTINE_TYPE="PROCEDURES"
                  elif echo "$OLD_PATH" | grep -qiE "(FUNCTIONS|FUNC)"; then
                    ROUTINE_TYPE="FUNCTIONS"
                  elif echo "$OLD_PATH" | grep -qiE "VIEWS"; then
                    ROUTINE_TYPE="VIEWS"
                  elif echo "$OLD_PATH" | grep -qiE "TRIGGERS"; then
                    ROUTINE_TYPE="TRIGGERS"
                  fi
                  
                  # Build new path
                  NEW_PATH="DB/ROUTINES/CORE/$ROUTINE_TYPE/$SQL_FILENAME"
                  
                  # Escape paths for sed
                  OLD_PATH_ESCAPED=$(echo "$OLD_PATH" | sed 's|/|\\/|g' | sed 's|\.|\\\.|g')
                  NEW_PATH_ESCAPED=$(echo "$NEW_PATH" | sed 's|/|\\/|g')
                  
                  # Update YAML file (try multiple patterns)
                  sed -i "s|path:[[:space:]]*$OLD_PATH_ESCAPED|path: $NEW_PATH_ESCAPED|g" "$COI_YAML" 2>/dev/null || true
                  sed -i "s|- path:[[:space:]]*$OLD_PATH_ESCAPED|- path: $NEW_PATH_ESCAPED|g" "$COI_YAML" 2>/dev/null || true
                  sed -i "s|$OLD_PATH_ESCAPED|$NEW_PATH_ESCAPED|g" "$COI_YAML" 2>/dev/null || true
                  
                  echo "  Updated: $OLD_PATH -> $NEW_PATH"
                done
              done
              echo "‚úÖ Finished updating YAML files"
            else
              echo "‚ö†Ô∏è  No YAML files found in COI repo to update"
            fi
            
            cd ..
          fi
          
          # ============================================
          # CREATE FEATURE BRANCH AND PULL REQUEST
          # ============================================
          cd coi-repo
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Get the target branch name from source repository (will be used as base branch for PR)
          SOURCE_BRANCH="${{ steps.branch.outputs.branch_name }}"
          TARGET_BRANCH="$SOURCE_BRANCH"
          
          # Try to use main/master as base branch if target branch doesn't exist in COI
          if ! git ls-remote --heads origin "$TARGET_BRANCH" | grep -q "$TARGET_BRANCH"; then
            if git ls-remote --heads origin "main" | grep -q "main"; then
              TARGET_BRANCH="main"
            elif git ls-remote --heads origin "master" | grep -q "master"; then
              TARGET_BRANCH="master"
            else
              echo "‚ö†Ô∏è  Target branch $SOURCE_BRANCH not found, and no main/master branch found. Will create new branch."
            fi
          fi
          
          # Checkout target branch first to get latest changes
          echo "Fetching latest from origin..."
          git fetch origin "$TARGET_BRANCH" || git fetch origin || true
          
          if git ls-remote --heads origin "$TARGET_BRANCH" | grep -q "$TARGET_BRANCH"; then
            echo "Checking out target branch: $TARGET_BRANCH"
            git checkout "$TARGET_BRANCH"
            git pull origin "$TARGET_BRANCH" || true
          else
            echo "Target branch $TARGET_BRANCH doesn't exist, will create it"
            git checkout -b "$TARGET_BRANCH" || git checkout "$TARGET_BRANCH" || true
          fi
          
          # Configure remote URL with token
          git remote set-url origin https://x-access-token:${{ secrets.GH_COI_PUSH_TOKEN }}@github.com/eprabhu/coi.git
          
          # Create feature branch name (unique for each sync)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          FEATURE_BRANCH="sync/core-from-fibi-test-${SOURCE_BRANCH}-${TIMESTAMP}"
          # Clean branch name (remove invalid characters)
          FEATURE_BRANCH=$(echo "$FEATURE_BRANCH" | sed 's/[^a-zA-Z0-9._-]/-/g' | cut -c1-100)
          
          echo "Creating feature branch: $FEATURE_BRANCH"
          git checkout -b "$FEATURE_BRANCH" || {
            echo "Feature branch may already exist, checking out..."
            git checkout "$FEATURE_BRANCH"
            git merge "$TARGET_BRANCH" || true
          }
          
          # STRICTLY ONLY modify DB/CORE/ and DB/ROUTINES/ directories
          # Add CORE changes (scripts YAML files)
          if [ -d "DB/CORE" ]; then
            git add DB/CORE/ || true
          fi
          
          # Add ROUTINES changes (SQL files)
          if [ -d "DB/ROUTINES" ]; then
            git add DB/ROUTINES/ || true
          fi
          
          # Safety check: Verify we're only staging DB/CORE/ and DB/ROUTINES/
          STAGED_FILES=$(git diff --cached --name-only 2>/dev/null || echo "")
          UNAUTHORIZED_FILES=$(echo "$STAGED_FILES" | grep -v "^DB/CORE/" | grep -v "^DB/ROUTINES/" | grep -v "^$" || true)
          
          if [ -n "$UNAUTHORIZED_FILES" ]; then
            echo "‚ö†Ô∏è  WARNING: Attempted to stage files outside DB/CORE/ and DB/ROUTINES/:"
            echo "$UNAUTHORIZED_FILES"
            echo "Resetting unauthorized files..."
            git reset HEAD $UNAUTHORIZED_FILES 2>/dev/null || true
          fi
          
          # Check if there are any changes to commit
          CHANGES=$(git status --porcelain DB/CORE 2>/dev/null || echo "")
          if [ -d "DB/ROUTINES" ]; then
            CHANGES="$CHANGES $(git status --porcelain DB/ROUTINES/ 2>/dev/null || echo "")"
          fi
          CHANGES=$(echo "$CHANGES" | xargs)
          
          if [ -n "$CHANGES" ]; then
            echo "Committing changes to feature branch..."
            COMMIT_MSG="Auto-sync CORE and ROUTINES from fibi-test"$'\n'$'\n'"Source commit: ${{ github.sha }}"$'\n'"Source branch: $SOURCE_BRANCH"$'\n'"Source repository: ${{ github.repository }}"$'\n'"Workflow run: ${{ github.run_id }}"$'\n'"Triggered by: ${{ github.actor }}"
            git commit -m "$COMMIT_MSG"
            
            echo "Pushing feature branch: $FEATURE_BRANCH to COI repository..."
            git push origin "$FEATURE_BRANCH" || git push -u origin "$FEATURE_BRANCH" || {
              echo "‚ö†Ô∏è  Failed to push feature branch"
              exit 1
            }
            
            echo "‚úÖ Feature branch pushed successfully"
            
            # Create Pull Request using GitHub API
            echo "Creating Pull Request..."
            PR_TITLE="üîÑ Auto-sync: CORE and ROUTINES from fibi-test ($SOURCE_BRANCH)"
            # Build PR body with escaped newlines to avoid YAML parsing issues
            PR_BODY="## üîÑ Auto-sync CORE and ROUTINES from fibi-test"$'\n'$'\n'"This PR was automatically created by the sync workflow."$'\n'$'\n'"### Source Information"$'\n'"- **Source Repository**: ${{ github.repository }}"$'\n'"- **Source Branch**: \`$SOURCE_BRANCH\`"$'\n'"- **Source Commit**: \`${{ github.sha }}\`"$'\n'"- **Workflow Run**: [View Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})"$'\n'"- **Triggered by**: @${{ github.actor }}"$'\n'$'\n'"### Changes"$'\n'"This PR syncs CORE scripts and ROUTINES from the following locations:"$'\n'"- Release folders: \`Fibi-*-Release/BASE/CORE/**\`"$'\n'"- Sprint folders: \`Sprint-*/BASE/CORE/**\`"$'\n'$'\n'"### Review Checklist"$'\n'"- [ ] Review CORE script changes in \`DB/CORE/\`"$'\n'"- [ ] Review ROUTINES changes in \`DB/ROUTINES/\`"$'\n'"- [ ] Verify file paths are correct"$'\n'"- [ ] Check for any breaking changes"$'\n'$'\n'"### Note"$'\n'"This PR only modifies files in \`DB/CORE/\` and \`DB/ROUTINES/\` directories. No other files are affected."
            
            # Escape PR body for JSON
            PR_BODY_ESCAPED=$(echo "$PR_BODY" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
            
            # Create PR using GitHub API
            PR_JSON="{\"title\":\"$PR_TITLE\",\"body\":\"$PR_BODY_ESCAPED\",\"head\":\"$FEATURE_BRANCH\",\"base\":\"$TARGET_BRANCH\"}"
            
            PR_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Authorization: token $GH_COI_PUSH_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$PR_JSON" \
              https://api.github.com/repos/eprabhu/coi/pulls)
            
            HTTP_CODE=$(echo "$PR_RESPONSE" | tail -n1)
            PR_BODY_RESPONSE=$(echo "$PR_RESPONSE" | sed '$d')
            
            if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "200" ]; then
              PR_URL=$(echo "$PR_BODY_RESPONSE" | grep -o '"html_url":"[^"]*' | cut -d'"' -f4 || echo "")
              PR_NUMBER=$(echo "$PR_BODY_RESPONSE" | grep -o '"number":[0-9]*' | cut -d':' -f2 || echo "")
              
              echo "‚úÖ Pull Request created successfully"
              if [ -n "$PR_URL" ]; then
                echo "üîó PR Link: $PR_URL"
                
                # Try to add label if PR number is available
                if [ -n "$PR_NUMBER" ]; then
                  curl -s -X POST \
                    -H "Accept: application/vnd.github.v3+json" \
                    -H "Authorization: token $GH_COI_PUSH_TOKEN" \
                    -H "Content-Type: application/json" \
                    -d '{"labels":["auto-sync"]}' \
                    https://api.github.com/repos/eprabhu/coi/issues/$PR_NUMBER/labels > /dev/null || true
                fi
              fi
            elif [ "$HTTP_CODE" = "422" ]; then
              # PR might already exist, try to find it
              EXISTING_PR_RESPONSE=$(curl -s \
                -H "Accept: application/vnd.github.v3+json" \
                -H "Authorization: token $GH_COI_PUSH_TOKEN" \
                "https://api.github.com/repos/eprabhu/coi/pulls?head=eprabhu:$FEATURE_BRANCH&base=$TARGET_BRANCH&state=open")
              
              EXISTING_PR_URL=$(echo "$EXISTING_PR_RESPONSE" | grep -o '"html_url":"[^"]*' | head -1 | cut -d'"' -f4 || echo "")
              
              if [ -n "$EXISTING_PR_URL" ]; then
                echo "‚ö†Ô∏è  Pull Request already exists"
                echo "üîó Existing PR Link: $EXISTING_PR_URL"
              else
                echo "‚ö†Ô∏è  Failed to create PR (HTTP $HTTP_CODE). Response: $PR_BODY_RESPONSE"
                echo "üîó Please create PR manually: https://github.com/eprabhu/coi/compare/$TARGET_BRANCH...$FEATURE_BRANCH"
                echo "PR Title: $PR_TITLE"
              fi
            else
              echo "‚ö†Ô∏è  Failed to create PR (HTTP $HTTP_CODE). Response: $PR_BODY_RESPONSE"
              echo "üîó Please create PR manually: https://github.com/eprabhu/coi/compare/$TARGET_BRANCH...$FEATURE_BRANCH"
              echo "PR Title: $PR_TITLE"
            fi
          else
            echo "No changes to commit. Already in sync."
            # Delete feature branch if no changes
            git checkout "$TARGET_BRANCH" || true
            git branch -D "$FEATURE_BRANCH" || true
            git push origin --delete "$FEATURE_BRANCH" || true
          fi
      
      - name: Send failure notification email
        if: failure()
        continue-on-error: true
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "‚ùå CORE Sync Failed - fibi-test to COI Repository"
          to: ${{ steps.author.outputs.author_email }},prabhu.e@polussolutions.com
          from: GitHub Actions <${{ secrets.EMAIL_USERNAME }}>
          body: |
            <h2>‚ùå CORE Sync Workflow Failed</h2>
            
            <p><strong>Repository:</strong> ${{ github.repository }}</p>
            <p><strong>Commit:</strong> <code>${{ github.sha }}</code></p>
            <p><strong>Commit Message:</strong> ${{ github.event.head_commit.message }}</p>
            <p><strong>Author:</strong> ${{ steps.author.outputs.author_name }} (${{ steps.author.outputs.author_email }})</p>
            <p><strong>Branch:</strong> ${{ github.ref_name }}</p>
            <p><strong>Workflow:</strong> Sync CORE to COI</p>
            <p><strong>Run ID:</strong> ${{ github.run_id }}</p>
            
            <hr>
            
            <h3>View Error Details:</h3>
            <p><a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Click here to view the workflow run and error logs</a></p>
            
            <p><strong>Direct Link:</strong><br>
            <code>${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}</code></p>
            
            <hr>
            
            <p><small>This is an automated notification from GitHub Actions. Please check the workflow logs for detailed error information.</small></p>
          content_type: text/html

