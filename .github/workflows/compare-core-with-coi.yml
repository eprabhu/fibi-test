name: Compare CORE with COI

on:
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Target branch in COI repository (leave empty to use current branch)'
        required: false
        type: string
        default: ''

permissions:
  contents: read

jobs:
  compare:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout fibi-test
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      - name: Determine target branch
        id: branch
        run: |
          # Use provided branch or default to current branch
          if [ -n "${{ github.event.inputs.target_branch }}" ]; then
            BRANCH_NAME="${{ github.event.inputs.target_branch }}"
            echo "Using provided target branch: $BRANCH_NAME"
          else
            BRANCH_NAME="${{ github.ref_name }}"
            echo "Using current branch: $BRANCH_NAME"
          fi
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "Target branch: $BRANCH_NAME"
      
      - name: Checkout COI
        run: |
          echo "Cloning COI repository..."
          git clone https://github.com/eprabhu/coi.git coi-repo
          cd coi-repo
          
          # Get the target branch name
          TARGET_BRANCH="${{ steps.branch.outputs.branch_name }}"
          echo "Checking out branch: $TARGET_BRANCH"
          
          # Check if branch exists in COI repository
          if git ls-remote --heads origin "$TARGET_BRANCH" | grep -q "$TARGET_BRANCH"; then
            echo "Branch $TARGET_BRANCH exists in COI, checking it out..."
            git checkout "$TARGET_BRANCH"
          else
            echo "âš ï¸  Branch $TARGET_BRANCH does not exist in COI, using default branch"
            git checkout main || git checkout master || echo "Using current branch"
          fi
      
      - name: Compare CORE and ROUTINES
        id: compare
        run: |
          set +e  # Don't exit on error, we want to continue and report all issues
          
          echo "ðŸ” Comparing CORE and ROUTINES between fibi-test and COI..."
          echo ""
          
          # Create comparison report file
          REPORT_FILE="comparison-report.txt"
          echo "========================================" > "$REPORT_FILE"
          echo "CORE & ROUTINES COMPARISON REPORT" >> "$REPORT_FILE"
          echo "========================================" >> "$REPORT_FILE"
          echo "Generated: $(date)" >> "$REPORT_FILE"
          echo "Source: fibi-test (${{ github.ref_name }})" >> "$REPORT_FILE"
          echo "Target: COI (${{ steps.branch.outputs.branch_name }})" >> "$REPORT_FILE"
          echo "" >> "$REPORT_FILE"
          
          UNSYNCED_COUNT=0
          
          # ============================================
          # COMPARE RELEASE CORE FOLDERS
          # ============================================
          echo "ðŸ“¦ Comparing Release CORE folders..." >> "$REPORT_FILE"
          echo "----------------------------------------" >> "$REPORT_FILE"
          
          # Find all release folders in source
          RELEASE_FOLDERS=$(find . -maxdepth 1 -type d -name "Fibi-*-Release" | sort)
          
          if [ -n "$RELEASE_FOLDERS" ]; then
            for RELEASE_DIR in $RELEASE_FOLDERS; do
              RELEASE_NAME=$(basename "$RELEASE_DIR")
              echo "Processing release: $RELEASE_NAME" >> "$REPORT_FILE"
              
              # Only check BASE/CORE
              CORE_PATH="$RELEASE_DIR/BASE/CORE"
              
              if [ -d "$CORE_PATH" ]; then
                # Find all files in source CORE
                find "$CORE_PATH" -type f ! -path "*/.git/*" | sort > /tmp/fibi_release_files.txt
                
                # Find all files in destination
                DEST_RELEASE_DIR="coi-repo/DB/CORE/$RELEASE_NAME"
                if [ -d "$DEST_RELEASE_DIR" ]; then
                  find "$DEST_RELEASE_DIR" -type f ! -path "*/.git/*" | sort > /tmp/coi_release_files.txt
                else
                  touch /tmp/coi_release_files.txt
                fi
                
                # Compare files
                while IFS= read -r SOURCE_FILE || [ -n "$SOURCE_FILE" ]; do
                  if [ -z "$SOURCE_FILE" ]; then
                    continue
                  fi
                  RELATIVE_PATH=$(echo "$SOURCE_FILE" | sed "s|^$CORE_PATH/||")
                  DEST_FILE="$DEST_RELEASE_DIR/$RELATIVE_PATH"
                  
                  if [ ! -f "$DEST_FILE" ]; then
                    echo "âŒ MISSING: $RELEASE_NAME/$RELATIVE_PATH (exists in fibi-test, not in COI)" >> "$REPORT_FILE"
                    UNSYNCED_COUNT=$((UNSYNCED_COUNT + 1))
                  elif ! cmp -s "$SOURCE_FILE" "$DEST_FILE" 2>/dev/null; then
                    echo "âš ï¸  DIFFERENT: $RELEASE_NAME/$RELATIVE_PATH (content differs)" >> "$REPORT_FILE"
                    UNSYNCED_COUNT=$((UNSYNCED_COUNT + 1))
                  fi
                done < /tmp/fibi_release_files.txt
                
                # Check for orphaned files in COI
                while IFS= read -r DEST_FILE || [ -n "$DEST_FILE" ]; do
                  if [ -z "$DEST_FILE" ]; then
                    continue
                  fi
                  if [ -f "$DEST_FILE" ]; then
                    RELATIVE_PATH=$(echo "$DEST_FILE" | sed "s|^$DEST_RELEASE_DIR/||")
                    SOURCE_FILE="$CORE_PATH/$RELATIVE_PATH"
                    
                    if [ ! -f "$SOURCE_FILE" ]; then
                      echo "ðŸ“Œ ORPHANED: $RELEASE_NAME/$RELATIVE_PATH (exists in COI, not in fibi-test)" >> "$REPORT_FILE"
                    fi
                  fi
                done < /tmp/coi_release_files.txt
                
                if [ ! -d "$DEST_RELEASE_DIR" ]; then
                  echo "âŒ MISSING RELEASE: $RELEASE_NAME (entire release folder missing in COI)" >> "$REPORT_FILE"
                  UNSYNCED_COUNT=$((UNSYNCED_COUNT + 1))
                fi
              else
                echo "âš ï¸  No BASE/CORE folder found in $RELEASE_NAME" >> "$REPORT_FILE"
              fi
              
              echo "" >> "$REPORT_FILE"
            done
          else
            echo "âš ï¸  No release folders found" >> "$REPORT_FILE"
          fi
          
          # ============================================
          # COMPARE SPRINT CORE FOLDERS
          # ============================================
          echo "ðŸ“¦ Comparing Sprint CORE folders..." >> "$REPORT_FILE"
          echo "----------------------------------------" >> "$REPORT_FILE"
          
          # Find all sprint folders in source
          SPRINT_FOLDERS=$(find . -maxdepth 1 -type d -name "Sprint-*" | sort)
          
          if [ -n "$SPRINT_FOLDERS" ]; then
            for SPRINT_DIR in $SPRINT_FOLDERS; do
              SPRINT_NAME=$(basename "$SPRINT_DIR")
              echo "Processing sprint: $SPRINT_NAME" >> "$REPORT_FILE"
              
              # Only check BASE/CORE
              CORE_PATH="$SPRINT_DIR/BASE/CORE"
              
              if [ -d "$CORE_PATH" ]; then
                # Find all files in source CORE
                find "$CORE_PATH" -type f ! -path "*/.git/*" | sort > /tmp/fibi_sprint_files.txt
                
                # Find all files in destination
                DEST_SPRINT_DIR="coi-repo/DB/CORE/$SPRINT_NAME"
                if [ -d "$DEST_SPRINT_DIR" ]; then
                  find "$DEST_SPRINT_DIR" -type f ! -path "*/.git/*" | sort > /tmp/coi_sprint_files.txt
                else
                  touch /tmp/coi_sprint_files.txt
                fi
                
                # Compare files
                while IFS= read -r SOURCE_FILE || [ -n "$SOURCE_FILE" ]; do
                  if [ -z "$SOURCE_FILE" ]; then
                    continue
                  fi
                  RELATIVE_PATH=$(echo "$SOURCE_FILE" | sed "s|^$CORE_PATH/||")
                  DEST_FILE="$DEST_SPRINT_DIR/$RELATIVE_PATH"
                  
                  if [ ! -f "$DEST_FILE" ]; then
                    echo "âŒ MISSING: $SPRINT_NAME/$RELATIVE_PATH (exists in fibi-test, not in COI)" >> "$REPORT_FILE"
                    UNSYNCED_COUNT=$((UNSYNCED_COUNT + 1))
                  elif ! cmp -s "$SOURCE_FILE" "$DEST_FILE" 2>/dev/null; then
                    echo "âš ï¸  DIFFERENT: $SPRINT_NAME/$RELATIVE_PATH (content differs)" >> "$REPORT_FILE"
                    UNSYNCED_COUNT=$((UNSYNCED_COUNT + 1))
                  fi
                done < /tmp/fibi_sprint_files.txt
                
                # Check for orphaned files in COI
                while IFS= read -r DEST_FILE || [ -n "$DEST_FILE" ]; do
                  if [ -z "$DEST_FILE" ]; then
                    continue
                  fi
                  if [ -f "$DEST_FILE" ]; then
                    RELATIVE_PATH=$(echo "$DEST_FILE" | sed "s|^$DEST_SPRINT_DIR/||")
                    SOURCE_FILE="$CORE_PATH/$RELATIVE_PATH"
                    
                    if [ ! -f "$SOURCE_FILE" ]; then
                      echo "ðŸ“Œ ORPHANED: $SPRINT_NAME/$RELATIVE_PATH (exists in COI, not in fibi-test)" >> "$REPORT_FILE"
                    fi
                  fi
                done < /tmp/coi_sprint_files.txt
                
                if [ ! -d "$DEST_SPRINT_DIR" ]; then
                  echo "âŒ MISSING SPRINT: $SPRINT_NAME (entire sprint folder missing in COI)" >> "$REPORT_FILE"
                  UNSYNCED_COUNT=$((UNSYNCED_COUNT + 1))
                fi
              else
                echo "âš ï¸  No BASE/CORE folder found in $SPRINT_NAME" >> "$REPORT_FILE"
              fi
              
              echo "" >> "$REPORT_FILE"
            done
          else
            echo "âš ï¸  No sprint folders found" >> "$REPORT_FILE"
          fi
          
          # ============================================
          # COMPARE ROUTINES FILES
          # ============================================
          echo "ðŸ“¦ Comparing ROUTINES files..." >> "$REPORT_FILE"
          echo "----------------------------------------" >> "$REPORT_FILE"
          
          # Find all routines YAML files - ONLY from BASE/CORE
          ROUTINES_YAML_FILES=$(find . -type f \( -name "PROCEDURES.yaml" -o -name "PROCEDURES.yml" -o -name "VIEWS.yaml" -o -name "VIEWS.yml" -o -name "FUNCTIONS.yaml" -o -name "FUNCTIONS.yml" -o -name "TRIGGERS.yaml" -o -name "TRIGGERS.yml" \) -path "*/BASE/CORE/*" ! -path "*/.git/*" ! -path "*/coi-repo/*" | sort)
          
          if [ -n "$ROUTINES_YAML_FILES" ]; then
            for YAML_FILE in $ROUTINES_YAML_FILES; do
              echo "Processing YAML file: $YAML_FILE" >> "$REPORT_FILE"
              
              # Extract all sqlFile paths from YAML
              SQL_PATHS=$(awk '/sqlFile:/{getline; if(/path:/){gsub(/.*path:[[:space:]]*/, ""); gsub(/[[:space:]]*$/, ""); if($0 != "") print}}' "$YAML_FILE" || true)
              
              if [ -z "$SQL_PATHS" ]; then
                continue
              fi
              
              # Check each SQL file
              for SQL_PATH in $SQL_PATHS; do
                SQL_PATH=$(echo "$SQL_PATH" | xargs)
                SQL_FILENAME=$(basename "$SQL_PATH")
                
                # Find source file using same strategies as sync workflow
                SOURCE_FILE=""
                
                # Strategy 1: Try path as-is
                if [ -f "$SQL_PATH" ]; then
                  SOURCE_FILE="$SQL_PATH"
                fi
                
                # Strategy 2: If path starts with ROUTINES/FIBI_CORE, try ROUTINES/BASE/FIBI_CORE
                if [ -z "$SOURCE_FILE" ] && echo "$SQL_PATH" | grep -q "^ROUTINES/FIBI_CORE"; then
                  BASE_PATH=$(echo "$SQL_PATH" | sed 's|^ROUTINES/FIBI_CORE|ROUTINES/BASE/FIBI_CORE|')
                  if [ -f "$BASE_PATH" ]; then
                    SOURCE_FILE="$BASE_PATH"
                  fi
                fi
                
                # Strategy 3: If path starts with ROUTINES/CORE, try ROUTINES/BASE/CORE
                if [ -z "$SOURCE_FILE" ] && echo "$SQL_PATH" | grep -q "^ROUTINES/CORE"; then
                  BASE_PATH=$(echo "$SQL_PATH" | sed 's|^ROUTINES/CORE|ROUTINES/BASE/CORE|')
                  if [ -f "$BASE_PATH" ]; then
                    SOURCE_FILE="$BASE_PATH"
                  fi
                fi
                
                # Strategy 4: Try ROUTINES/BASE/ + relative path from ROUTINES/
                if [ -z "$SOURCE_FILE" ] && echo "$SQL_PATH" | grep -q "^ROUTINES/"; then
                  RELATIVE_PATH=$(echo "$SQL_PATH" | sed 's|^ROUTINES/||')
                  TRY_PATH="ROUTINES/BASE/$RELATIVE_PATH"
                  if [ -f "$TRY_PATH" ]; then
                    SOURCE_FILE="$TRY_PATH"
                  fi
                fi
                
                # Strategy 5: Find by filename in ROUTINES directories
                if [ -z "$SOURCE_FILE" ]; then
                  SOURCE_FILE=$(find . -type f -name "$SQL_FILENAME" ! -path "*/.git/*" ! -path "*/coi-repo/*" | grep -E "ROUTINES.*(CORE|FIBI_CORE)" | head -1)
                fi
                
                # Strategy 6: Find by path pattern (last resort)
                if [ -z "$SOURCE_FILE" ]; then
                  SOURCE_FILE=$(find . -type f -path "*/$SQL_PATH" ! -path "*/.git/*" ! -path "*/coi-repo/*" | head -1)
                fi
                
                if [ -n "$SOURCE_FILE" ] && [ -f "$SOURCE_FILE" ]; then
                  # Determine destination path: DB/ROUTINES/CORE/(PROCEDURES|FUNCTIONS|VIEWS)/*.sql
                  SQL_FILENAME=$(basename "$SOURCE_FILE")
                  
                  # Extract type (PROCEDURES, FUNCTIONS, VIEWS, TRIGGERS) from source path
                  ROUTINE_TYPE=""
                  if echo "$SOURCE_FILE" | grep -qiE "(PROCEDURES|PROC)"; then
                    ROUTINE_TYPE="PROCEDURES"
                  elif echo "$SOURCE_FILE" | grep -qiE "(FUNCTIONS|FUNC)"; then
                    ROUTINE_TYPE="FUNCTIONS"
                  elif echo "$SOURCE_FILE" | grep -qiE "VIEWS"; then
                    ROUTINE_TYPE="VIEWS"
                  elif echo "$SOURCE_FILE" | grep -qiE "TRIGGERS"; then
                    ROUTINE_TYPE="TRIGGERS"
                  else
                    # Try to extract from path structure
                    if echo "$SOURCE_FILE" | grep -qE "/PROCEDURES/"; then
                      ROUTINE_TYPE="PROCEDURES"
                    elif echo "$SOURCE_FILE" | grep -qE "/FUNCTIONS/"; then
                      ROUTINE_TYPE="FUNCTIONS"
                    elif echo "$SOURCE_FILE" | grep -qE "/VIEWS/"; then
                      ROUTINE_TYPE="VIEWS"
                    elif echo "$SOURCE_FILE" | grep -qE "/TRIGGERS/"; then
                      ROUTINE_TYPE="TRIGGERS"
                    else
                      # Default to FUNCTIONS if cannot determine
                      ROUTINE_TYPE="FUNCTIONS"
                    fi
                  fi
                  
                  # Build destination: DB/ROUTINES/CORE/{TYPE}/{filename}.sql
                  DEST_PATH="DB/ROUTINES/CORE/$ROUTINE_TYPE/$SQL_FILENAME"
                  DEST_FILE="coi-repo/$DEST_PATH"
                  
                  if [ ! -f "$DEST_FILE" ]; then
                    echo "âŒ MISSING ROUTINE: $DEST_PATH (exists in fibi-test, not in COI)" >> "$REPORT_FILE"
                    UNSYNCED_COUNT=$((UNSYNCED_COUNT + 1))
                  elif ! cmp -s "$SOURCE_FILE" "$DEST_FILE" 2>/dev/null; then
                    echo "âš ï¸  DIFFERENT ROUTINE: $DEST_PATH (content differs)" >> "$REPORT_FILE"
                    UNSYNCED_COUNT=$((UNSYNCED_COUNT + 1))
                  fi
                fi
              done
            done
          else
            echo "âš ï¸  No routines YAML files found" >> "$REPORT_FILE"
          fi
          
          echo "" >> "$REPORT_FILE"
          echo "========================================" >> "$REPORT_FILE"
          echo "SUMMARY" >> "$REPORT_FILE"
          echo "========================================" >> "$REPORT_FILE"
          echo "Total unsynced files: $UNSYNCED_COUNT" >> "$REPORT_FILE"
          
          if [ $UNSYNCED_COUNT -eq 0 ]; then
            echo "âœ… All CORE and ROUTINES files are in sync!" >> "$REPORT_FILE"
          else
            echo "âŒ Found $UNSYNCED_COUNT unsynced file(s)" >> "$REPORT_FILE"
          fi
          
          echo "" >> "$REPORT_FILE"
          echo "========================================" >> "$REPORT_FILE"
          
          # Display report
          cat "$REPORT_FILE"
          
          # Save report as artifact
          echo "UNSYNCED_COUNT=$UNSYNCED_COUNT" >> $GITHUB_OUTPUT
          
          # Exit with success (we want to report even if there are differences)
          exit 0
      
      - name: Upload comparison report
        uses: actions/upload-artifact@v4
        with:
          name: core-comparison-report
          path: comparison-report.txt
          retention-days: 30
      
      - name: Set job summary
        run: |
          UNSYNCED_COUNT="${{ steps.compare.outputs.UNSYNCED_COUNT }}"
          if [ -z "$UNSYNCED_COUNT" ]; then
            UNSYNCED_COUNT="0"
          fi
          if [ "$UNSYNCED_COUNT" = "0" ]; then
            echo "## âœ… Comparison Complete" >> $GITHUB_STEP_SUMMARY
            echo "All CORE and ROUTINES files are in sync!" >> $GITHUB_STEP_SUMMARY
          else
            echo "## âš ï¸ Comparison Complete" >> $GITHUB_STEP_SUMMARY
            echo "Found **$UNSYNCED_COUNT** unsynced file(s)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“¥ Download the full report from the artifacts section above." >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Source Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target Branch:** ${{ steps.branch.outputs.branch_name }}" >> $GITHUB_STEP_SUMMARY

