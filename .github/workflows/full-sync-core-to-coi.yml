name: Full Sync CORE to COI

on:
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Target branch in COI repository (leave empty to use current branch)'
        required: false
        type: string
        default: ''

permissions:
  contents: write

jobs:
  full-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout fibi-test
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      - name: Get commit author info
        id: author
        run: |
          AUTHOR_EMAIL=$(git log -1 --pretty=format:"%ae" || echo "${{ github.actor }}@users.noreply.github.com")
          AUTHOR_NAME=$(git log -1 --pretty=format:"%an" || echo "${{ github.actor }}")
          echo "author_email=$AUTHOR_EMAIL" >> $GITHUB_OUTPUT
          echo "author_name=$AUTHOR_NAME" >> $GITHUB_OUTPUT
          echo "Commit author: $AUTHOR_NAME <$AUTHOR_EMAIL>"
      
      - name: Determine target branch
        id: branch
        run: |
          # Use provided branch or default to current branch
          if [ -n "${{ github.event.inputs.target_branch }}" ]; then
            BRANCH_NAME="${{ github.event.inputs.target_branch }}"
            echo "Using provided target branch: $BRANCH_NAME"
          else
            BRANCH_NAME="${{ github.ref_name }}"
            echo "Using current branch: $BRANCH_NAME"
          fi
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "Target branch: $BRANCH_NAME"
      
      - name: Verify Secret
        run: |
          if [ -z "$GH_COI_PUSH_TOKEN" ]; then
            echo "‚ùå ERROR: GH_COI_PUSH_TOKEN secret is empty or not set!"
            echo "Please check: https://github.com/eprabhu/fibi-test/settings/secrets/actions"
            exit 1
          else
            TOKEN_LENGTH=${#GH_COI_PUSH_TOKEN}
            echo "‚úÖ Token secret exists (length: $TOKEN_LENGTH characters)"
            if [ $TOKEN_LENGTH -lt 10 ]; then
              echo "‚ö†Ô∏è  WARNING: Token seems too short. Please verify it's correct."
            fi
          fi
        env:
          GH_COI_PUSH_TOKEN: ${{ secrets.GH_COI_PUSH_TOKEN }}
      
      - name: Checkout COI
        run: |
          echo "Cloning COI repository..."
          git clone https://x-access-token:$GH_COI_PUSH_TOKEN@github.com/eprabhu/coi.git coi-repo
          cd coi-repo
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Get the target branch name
          TARGET_BRANCH="${{ steps.branch.outputs.branch_name }}"
          echo "Checking out branch: $TARGET_BRANCH"
          
          # Check if branch exists in COI repository
          if git ls-remote --heads origin "$TARGET_BRANCH" | grep -q "$TARGET_BRANCH"; then
            echo "Branch $TARGET_BRANCH exists in COI, checking it out..."
            git checkout "$TARGET_BRANCH"
          else
            echo "Branch $TARGET_BRANCH does not exist in COI, creating it..."
            git checkout -b "$TARGET_BRANCH"
          fi
        env:
          GH_COI_PUSH_TOKEN: ${{ secrets.GH_COI_PUSH_TOKEN }}
      
      - name: Full Sync CORE and ROUTINES
        env:
          GH_TOKEN: ${{ secrets.GH_COI_PUSH_TOKEN }}
        run: |
          echo "üîÑ Starting FULL SYNC of CORE and ROUTINES..."
          
          # Create base destination directory
          mkdir -p coi-repo/DB/CORE
          
          # ============================================
          # SYNC VANILLA CORE
          # ============================================
          if [ -d "Fibi-Vanilla/FIBI_CORE" ]; then
            echo "üì¶ Syncing Fibi-Vanilla CORE..."
            
            # Remove existing vanilla CORE files (preserve release folders)
            if [ -d "coi-repo/DB/CORE" ]; then
              find coi-repo/DB/CORE -maxdepth 1 -type f -delete || true
              find coi-repo/DB/CORE -maxdepth 1 -type d ! -name "CORE" ! -name "Fibi-*-Release" -exec rm -rf {} + || true
            fi
            
            # Copy all Vanilla CORE files
            cp -r Fibi-Vanilla/FIBI_CORE/* coi-repo/DB/CORE/ || true
            echo "‚úÖ Synced Fibi-Vanilla CORE"
          else
            echo "‚ö†Ô∏è  Fibi-Vanilla/FIBI_CORE directory not found, skipping"
          fi
          
          # ============================================
          # SYNC ALL RELEASE CORE FOLDERS
          # ============================================
          echo "üì¶ Syncing all Release CORE folders..."
          
          # Find all release folders
          RELEASE_FOLDERS=$(find . -maxdepth 1 -type d -name "Fibi-*-Release" | sort)
          
          if [ -n "$RELEASE_FOLDERS" ]; then
            for RELEASE_DIR in $RELEASE_FOLDERS; do
              RELEASE_NAME=$(basename "$RELEASE_DIR")
              echo "Processing release: $RELEASE_NAME"
              
              # Find CORE folder in this release - ONLY BASE/CORE (not client-based CORE)
              CORE_PATH="$RELEASE_DIR/BASE/CORE"
              
              if [ -n "$CORE_PATH" ] && [ -d "$CORE_PATH" ]; then
                echo "Found CORE folder at: $CORE_PATH"
                
                # Create destination directory for this release
                DEST_DIR="coi-repo/DB/CORE/$RELEASE_NAME"
                
                # Remove existing release folder if it exists (for clean sync)
                if [ -d "$DEST_DIR" ]; then
                  echo "Removing existing $RELEASE_NAME folder for clean sync..."
                  rm -rf "$DEST_DIR"
                fi
                
                # Create fresh directory
                mkdir -p "$DEST_DIR"
                
                # Copy CORE folder contents (not the CORE folder itself)
                echo "Copying from $CORE_PATH to $DEST_DIR"
                cp -r "$CORE_PATH"/* "$DEST_DIR/" || true
                
                echo "‚úÖ Synced $RELEASE_NAME CORE to $DEST_DIR"
              else
                echo "‚ö†Ô∏è  No CORE folder found in $RELEASE_NAME"
              fi
            done
          else
            echo "‚ö†Ô∏è  No release folders found"
          fi
          
          # ============================================
          # SYNC ALL ROUTINES FILES
          # ============================================
          echo "üì¶ Syncing all ROUTINES files from all YAML files..."
          
          # Find all routines YAML files - ONLY from BASE/CORE or Fibi-Vanilla/FIBI_CORE (exclude client-based CORE)
          ROUTINES_YAML_FILES=$(find . -type f \( -name "PROCEDURES.yaml" -o -name "PROCEDURES.yml" -o -name "VIEWS.yaml" -o -name "VIEWS.yml" -o -name "FUNCTIONS.yaml" -o -name "FUNCTIONS.yml" -o -name "TRIGGERS.yaml" -o -name "TRIGGERS.yml" \) \( -path "*/Fibi-Vanilla/FIBI_CORE/*" -o -path "*/BASE/CORE/*" \) ! -path "*/.git/*" ! -path "*/coi-repo/*" | sort)
          
          if [ -n "$ROUTINES_YAML_FILES" ]; then
            for YAML_FILE in $ROUTINES_YAML_FILES; do
              echo "Processing YAML file: $YAML_FILE"
              
              # Extract all sqlFile paths from YAML
              # Pattern: sqlFile: followed by path: on next line
              SQL_PATHS=$(awk '/sqlFile:/{getline; if(/path:/){gsub(/.*path:[[:space:]]*/, ""); gsub(/[[:space:]]*$/, ""); if($0 != "") print}}' "$YAML_FILE" || true)
              
              if [ -z "$SQL_PATHS" ]; then
                echo "No sqlFile paths found in $YAML_FILE"
                continue
              fi
              
              # Copy each SQL file
              for SQL_PATH in $SQL_PATHS; do
                echo "Found SQL path: $SQL_PATH"
                
                # Normalize path (remove leading/trailing spaces)
                SQL_PATH=$(echo "$SQL_PATH" | xargs)
                
                # Handle different path formats - find source file
                SOURCE_FILE=""
                SQL_FILENAME=$(basename "$SQL_PATH")
                
                # Strategy 1: Try path as-is
                if [ -f "$SQL_PATH" ]; then
                  SOURCE_FILE="$SQL_PATH"
                  echo "Found file at (as-is): $SQL_PATH"
                fi
                
                # Strategy 2: If path starts with ROUTINES/FIBI_CORE, try ROUTINES/BASE/FIBI_CORE
                if [ -z "$SOURCE_FILE" ] && echo "$SQL_PATH" | grep -q "^ROUTINES/FIBI_CORE"; then
                  BASE_PATH=$(echo "$SQL_PATH" | sed 's|^ROUTINES/FIBI_CORE|ROUTINES/BASE/FIBI_CORE|')
                  if [ -f "$BASE_PATH" ]; then
                    SOURCE_FILE="$BASE_PATH"
                    echo "Found file at (BASE FIBI_CORE path): $BASE_PATH"
                  fi
                fi
                
                # Strategy 3: If path starts with ROUTINES/CORE, try ROUTINES/BASE/CORE (common pattern)
                if [ -z "$SOURCE_FILE" ] && echo "$SQL_PATH" | grep -q "^ROUTINES/CORE"; then
                  BASE_PATH=$(echo "$SQL_PATH" | sed 's|^ROUTINES/CORE|ROUTINES/BASE/CORE|')
                  if [ -f "$BASE_PATH" ]; then
                    SOURCE_FILE="$BASE_PATH"
                    echo "Found file at (BASE path): $BASE_PATH"
                  fi
                fi
                
                # Strategy 4: Try ROUTINES/BASE/ + relative path from ROUTINES/
                if [ -z "$SOURCE_FILE" ] && echo "$SQL_PATH" | grep -q "^ROUTINES/"; then
                  RELATIVE_PATH=$(echo "$SQL_PATH" | sed 's|^ROUTINES/||')
                  TRY_PATH="ROUTINES/BASE/$RELATIVE_PATH"
                  if [ -f "$TRY_PATH" ]; then
                    SOURCE_FILE="$TRY_PATH"
                    echo "Found file at (BASE relative): $TRY_PATH"
                  fi
                fi
                
                # Strategy 5: Find file by name in ROUTINES directories
                if [ -z "$SOURCE_FILE" ]; then
                  echo "Searching for file by name: $SQL_FILENAME"
                  SOURCE_FILE=$(find . -type f -name "$SQL_FILENAME" ! -path "*/.git/*" ! -path "*/coi-repo/*" | grep -E "ROUTINES.*(CORE|FIBI_CORE)" | head -1)
                  if [ -n "$SOURCE_FILE" ]; then
                    echo "Found by filename at: $SOURCE_FILE"
                  fi
                fi
                
                # Strategy 6: Try with full path pattern (last resort)
                if [ -z "$SOURCE_FILE" ]; then
                  SOURCE_FILE=$(find . -type f -path "*/$SQL_PATH" ! -path "*/.git/*" ! -path "*/coi-repo/*" | head -1)
                  if [ -n "$SOURCE_FILE" ]; then
                    echo "Found by path pattern at: $SOURCE_FILE"
                  fi
                fi
                
                if [ -n "$SOURCE_FILE" ] && [ -f "$SOURCE_FILE" ]; then
                  # Determine destination path - place ROUTINES inside DB/ROUTINES/BASE/CORE/
                  # Use the original SQL_PATH from YAML for destination
                  SQL_PATH_CLEAN=$(echo "$SQL_PATH" | sed 's|^\./||')
                  
                  # Convert destination path: ROUTINES/FIBI_CORE or ROUTINES/CORE -> DB/ROUTINES/BASE/CORE
                  if echo "$SQL_PATH_CLEAN" | grep -q "^ROUTINES/FIBI_CORE"; then
                    # Vanilla CORE: ROUTINES/FIBI_CORE/... -> DB/ROUTINES/BASE/CORE/...
                    DEST_PATH=$(echo "$SQL_PATH_CLEAN" | sed 's|^ROUTINES/FIBI_CORE|DB/ROUTINES/BASE/CORE|')
                  elif echo "$SQL_PATH_CLEAN" | grep -q "^ROUTINES/CORE"; then
                    # Release CORE: ROUTINES/CORE/... -> DB/ROUTINES/BASE/CORE/...
                    DEST_PATH=$(echo "$SQL_PATH_CLEAN" | sed 's|^ROUTINES/CORE|DB/ROUTINES/BASE/CORE|')
                  else
                    # Other paths: ROUTINES/... -> DB/ROUTINES/BASE/...
                    DEST_PATH=$(echo "$SQL_PATH_CLEAN" | sed 's|^ROUTINES/|DB/ROUTINES/BASE/|')
                  fi
                  
                  DEST_FILE="coi-repo/$DEST_PATH"
                  DEST_DIR=$(dirname "$DEST_FILE")
                  
                  # Create destination directory (create parent directories if needed)
                  echo "Creating destination directory: $DEST_DIR"
                  mkdir -p "$DEST_DIR"
                  
                  # Copy the file (will replace if exists)
                  echo "Copying $SOURCE_FILE to $DEST_FILE"
                  cp -f "$SOURCE_FILE" "$DEST_FILE" || {
                    echo "‚ö†Ô∏è  Failed to copy $SOURCE_FILE to $DEST_FILE"
                    continue
                  }
                  echo "‚úÖ Synced routine file: $DEST_PATH"
                else
                  echo "‚ö†Ô∏è  SQL file not found: $SQL_PATH"
                  echo "   Searched paths:"
                  echo "   - $SQL_PATH"
                  if echo "$SQL_PATH" | grep -q "^ROUTINES/CORE"; then
                    BASE_PATH=$(echo "$SQL_PATH" | sed 's|^ROUTINES/CORE|ROUTINES/BASE/CORE|')
                    echo "   - $BASE_PATH"
                  fi
                  SQL_FILENAME=$(basename "$SQL_PATH")
                  echo "   - Files named: $SQL_FILENAME"
                fi
              done
            done
            
            echo "‚úÖ Finished syncing all ROUTINES files"
          else
            echo "‚ö†Ô∏è  No routines YAML files found"
          fi
          
          # ============================================
          # COMMIT AND PUSH
          # ============================================
          cd coi-repo
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Get the target branch name
          TARGET_BRANCH="${{ steps.branch.outputs.branch_name }}"
          echo "Syncing to branch: $TARGET_BRANCH"
          
          # Ensure we're on the correct branch
          CURRENT_BRANCH=$(git branch --show-current || echo "")
          if [ "$CURRENT_BRANCH" != "$TARGET_BRANCH" ]; then
            echo "Switching to branch: $TARGET_BRANCH"
            if git ls-remote --heads origin "$TARGET_BRANCH" | grep -q "$TARGET_BRANCH"; then
              git checkout "$TARGET_BRANCH"
            else
              git checkout -b "$TARGET_BRANCH"
            fi
          fi
          
          # Configure remote URL with token
          git remote set-url origin https://x-access-token:${{ secrets.GH_COI_PUSH_TOKEN }}@github.com/eprabhu/coi.git
          
          # Add CORE changes
          git add DB/CORE/ || true
          
          # Add ROUTINES changes if DB/ROUTINES directory exists
          if [ -d "DB/ROUTINES" ]; then
            git add DB/ROUTINES/ || true
          fi
          
          # Check if there are any changes to commit
          CHANGES=$(git status --porcelain DB/CORE 2>/dev/null || echo "")
          if [ -d "DB/ROUTINES" ]; then
            CHANGES="$CHANGES $(git status --porcelain DB/ROUTINES/ 2>/dev/null || echo "")"
          fi
          CHANGES=$(echo "$CHANGES" | xargs)
          
          if [ -n "$CHANGES" ]; then
            echo "Committing changes..."
            git commit -m "Full sync: CORE and ROUTINES from fibi-test

          Full sync performed via workflow_dispatch
          Source commit: ${{ github.sha }}
          Target branch: $TARGET_BRANCH
          Source repository: ${{ github.repository }}
          Triggered by: ${{ github.actor }}"
            
            echo "Pushing to COI repository (branch: $TARGET_BRANCH)..."
            git push origin "$TARGET_BRANCH" || git push -u origin "$TARGET_BRANCH"
            echo "‚úÖ Full sync completed successfully to branch: $TARGET_BRANCH"
          else
            echo "No changes to commit. Already in sync."
          fi
      
      - name: Send failure notification email
        if: failure()
        continue-on-error: true
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "‚ùå Full CORE Sync Failed - fibi-test to COI Repository"
          to: ${{ steps.author.outputs.author_email }},prabhu.e@polussolutions.com
          from: GitHub Actions <${{ secrets.EMAIL_USERNAME }}>
          body: |
            <h2>‚ùå Full CORE Sync Workflow Failed</h2>
            
            <p><strong>Repository:</strong> ${{ github.repository }}</p>
            <p><strong>Commit:</strong> <code>${{ github.sha }}</code></p>
            <p><strong>Triggered by:</strong> ${{ github.actor }}</p>
            <p><strong>Author:</strong> ${{ steps.author.outputs.author_name }} (${{ steps.author.outputs.author_email }})</p>
            <p><strong>Target Branch:</strong> ${{ steps.branch.outputs.branch_name }}</p>
            <p><strong>Workflow:</strong> Full Sync CORE to COI</p>
            <p><strong>Run ID:</strong> ${{ github.run_id }}</p>
            
            <hr>
            
            <h3>View Error Details:</h3>
            <p><a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">Click here to view the workflow run and error logs</a></p>
            
            <p><strong>Direct Link:</strong><br>
            <code>${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}</code></p>
            
            <hr>
            
            <p><small>This is an automated notification from GitHub Actions. Please check the workflow logs for detailed error information.</small></p>
          content_type: text/html

